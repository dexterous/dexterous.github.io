---
layout: post
title: Putting REST to rest
---

... or Why Implied Interfaces make for poor Implementations.<br /><blockquote><a href="http://en.wikipedia.org/w/index.php?title=Representational_State_Transfer">Representational state transfer</a> (REST) is a style of software architecture for distributed hypermedia systems such as the World Wide Web.</blockquote><div style="text-align: right;">- from <a href="http://wikipedia.org/">Wikipedia</a><br /></div><br />The term REST along with the <a href="http://en.wikipedia.org/w/index.php?title=Representational_State_Transfer#Principles">principles it implies</a> (or 'should' imply!) were put down in a <a href="http://www.ics.uci.edu/%7Efielding/pubs/dissertation/rest_arch_style.htm">doctoral disseration</a> by <a href="http://en.wikipedia.org/wiki/Roy_Fielding">Roy Fielding</a>.<br /><br />Actually IMHO, REST is just SOA and WS wrapped in a layer of OOP with just a generic Resource entity at the application layer. Even then, you kinda get to roll your own with everything- serialization, interaction, responses, validation...<br /><br />Well... OK, I may have over-genericised that. But, the funny thing is, that's the funny thing about REST! It is very generic.<br /><br />Even the primary 'Resource' definition is vague; the interface is almost completely implied-<br /><ul><li>POSTing to a URL creates a new resource (POSTing what?!)</li><li>I GET a resource referenceable at a given URL provided an id, otherwise... I get all resources at that URL (?); unless, of course, it is a singleton resource, in which case I get the singleton instance. :S</li><li>PUTting causes edits, although POSTs may behave in the same manner</li><li>HEADs can be used to detect the presence of a resource, while DELETEs... delete!<sup>[<a href="http://thinkaround.blogspot.com/2008/07/putting-rest-to-rest.html#note-1">1</a>]</sup></li><li>And I'm not even sure if OPTION and TRACE are relevant</li></ul>And that's just <span style="font-style: italic;">REST over HTTP</span>! <span style="font-weight: bold; font-style: italic;">Wait</span>!! Is there any <span style="font-style: italic;">other</span> REST?!? Well actually REST is a meta-architecture, it's protocol-agnostic. It's supposed to work for all hypermedia- so we should be able to do it over HTTP, FTP, SMTP, SNMP(?)...<br /><br />What is <span style="font-weight: bold;">hypermedia</span>? Media hopped up on too much sugar?!? Well, the Oxford Dictionary defines it as<br /><blockquote>an extension to hypertext providing multimedia facilities, such as sound and video.</blockquote>I don't know about you, but my brains just about ready to explode.<br /><br />But wait, it gets better. Some people liked the REST over HTTP idea so much that they forked their own flavour. So Fielding has Vanilla, while (these guys) have Extra Fudge! (all puns intended) It's called Web-Friendly services- services that behave reeeeally well with HTTP. Basically services that behave like web pages. Whoa! I'm getting asmx flashbacks!!! So I'm gonna shut up about that now.<br /><br />Then there's the <span style="font-weight: bold;">Hypermedia As The Engine Of State Transfer</span> <a href="http://www.pacificspirit.com/2006/03/31/hypermedia_as_the_engine_of_state_transfer">people</a><sup>[<a href="http://thinkaround.blogspot.com/2008/07/putting-rest-to-rest.html#note-2">2</a>]</sup>. These guys <span style="font-style: italic;">really </span>love the URL. To them the body is whatever it's gonna be! Now it's an XML document, now it could be a HTML FORM, then it could be a JSON object or, maybe, a <a href="http://en.wikipedia.org/wiki/HCard">hCard</a>. I'm sorry, but I can't comprehend this comically 'uniform' interface where your interaction modes are implied, reference end-points are overloaded and results are undefined, or implied, or... did you say they're documented somewhere?<br /><br />The question I arrive at, then, is- <span style="font-weight: bold;">why do we want to be RESTful or Web-Friendly?</span> The loudest argument I hear is that the infrastructure has has already been laid; web servers and proxies with caching, DNS servers, IP routers with path optimization algorithms, the whole kahuna! Think of all the automatic performance gains arising from all that caching! All the more reason to stick more stuff into the URL and fill up those HTTP parameters you never thought to use until now! You just ride the wave!<br /><br />Hmm... it would seem that REST intends to counter the end-to-end principle by allowing for intelligence (optimizations) at the nodes, but that's a little too debatable; so &lt;sidestep /&gt;.<br /><br />But stepping back a bit, lem'me get this right. We're trying to fit an <span style="font-weight: bold;">application protocol</span> directly over a <span style="font-weight: bold;">document delivery infrastructure</span>? <a href="http://pages.citebite.com/f6f9x0b6mrmy">You've gotta be  kiddin' me!</a> I'm not saying this can't be done, just not without a cost- <a href="http://en.wikipedia.org/wiki/Tanstaafl">TANSTAFL</a>. Just think about all the time you're going to spend on deciding and negotiating a wire format, and corresponding responses. And that's just one wire format. REST talks of 'representations', a resource could have more than one wire format! I don't know about you, but I've had trouble getting people to understand one wire format right, and now you're telling me they're gonna want to send 'resources' in XML, JSON, YAML, HTML, delimited strings, multi-fixed and EBCIDIC? Over my dead body!!!<br /><br />Plus, the wireformats are completely arbitrary. Every resource implementer gets to pich their own. So you end up having to 'understand' the specific wire format of every resource you interact with. And by 'understand' they mean RTFM. So much for convention over configuration. Just too much Knowledge in head vs Knowledge in world.<br /><br />Actually, the wire format is where it gets really funny. XML just had the attribute-element dilemma, REST elevates it to the payload-parameter dilemma! Most Web-Friendly service makers get away without a body to the requests, they just stick a bunch of 'required' HTTP parameters on to the resource URL. So much for 'representation' of 'state', we're back to representation of output. Why does this remind me so much of WS?<br /><br />I think REST could find application in internal applications where the domain model is well defined, where resources and their interactions are well defined. But I'd still be skeptical because I tried that once at work and we kinda crashed and burned. The biggest brick wall we hit was latency. Given the 'resource' unicycle that REST provided and the specific verbs HTTP provided made our resource interactions multi-stage, especially since REST is stateless. When updating a resource, I wanted to <span style="font-weight: bold;">GET</span> a representation of the current state of the resource, modify it and <span style="font-weight: bold;">PUT</span> the modified state representation back into its place. But others on the team felt that adhering to those principles added unnecessary communication overheads and chose to add interaction verbs, which was conveniently <a href="http://pages.citebite.com/v6i9h1r3cbrn">provided for by ActiveResource</a>. Oh, and that's just when we were not arguing about the wore formats.<br /><br />Honestly, if you ask me, the only reason REST wont go down the tube like <a href="http://en.wikipedia.org/wiki/List_of_Microsoft_codenames#.NET">Hailstorm</a> is because it's community driven, not governed and controlled by a megalomaniac. Everyone gets to roll their own and even fork while still calling it RESTful. But even if it does last, I think it's only going to be a buzzword that we'll all have a good laugh about in a few years-<br /><br />Raj: Hey Saager, we're building this new service for so-and-so and it's accessible via, get this... RESTful resources! :D<br />Me : Wait, are you sure they're not Web-UNfriendly?!? =D<br /><br /><a style="font-weight: bold;" name="note-1">1</a> the DELETE's about the most logical thing I got so far! :P<br /><a style="font-weight: bold;" name="note-2">2</a> sorry Dave, your post is the only one I could directly reference to HATEOS
